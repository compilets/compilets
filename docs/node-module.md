# Creating native Node.js modules

Compilets can turn a TypeScript module into a native Node.js module, with
following steps:

1. Translate the TypeScript to C++.
2. Add bindings code connecting C++ and JavaScript using
   [Node-API](https://nodejs.org/api/n-api.html).
4. Build naitve modules.

This documentation focuses on explaining the details behind the steps, for a
quick hands-on it is recommended to try the [quick-start repo](https://github.com/compilets/quick-start).

## Configurations

For a multi-file project, how does Compilets know which files should be built
into executables and which files should be native modules? It is determined by
the custom `"compilets"` field in the `package.json` file.

If a main script is specified by the `"compilets.main"` field (i.e.
`{"compilets": {"main": "main.ts"}}`), the exports of it will be exposed in the
native modules.

Similarly, the `"compilets.bin"` field can be used to specify the files to be
built as executables.

For other TypeScript files that do not appear in `package.json`, they will be
linked to the native modules and executables, so symbols implemented in other
files can be imported into the main script without bundlers.

## Translating to C++

The `compilets gen` command is responsible for translating a TypeScript project
to a C++ project, internally it does following things:

1. Translate the TypeScript code to C++ code.
2. Create a C++ project using [GN build system](https://gn.googlesource.com/gn/),
   which produces the `BUILD.gn` and `.gn` files.
3. Copy the C++ dependencies, which produces the `cpp/` directory.
4. Download the [standalone GN](https://github.com/yue/build-gn) to current
   user's cache directory.
5. Run `gn gen` to make the build directory `out/`.

The last step also exists as the `compilets gn-gen` command, which is used by
Compilets itself for building the C++ unit tests.

After running the `compilets gen` command, all the generated files will be put
in the `cpp-project/` directory under the root directory of the TypeScript
project. You can change it to other places with the `--target` flag.

## Node-API bindings

When there is a `"compilets.main"` field in the `package.json`, bindings code
will also be generated in the translated C++ file of the main script. In the
case of `{"compilets": {"main": "main.ts"}}`, it is the `cpp-project/main.cpp`
file.

The bindings code uses [kizunapi](https://github.com/yue/kizunapi) to implicitly
translate C++ interfaces to JavaScript with `Node-API`. Many information in the
original TypeScript code are lost during this step, for example `readonly` and
optional parameters. We will try to tackle this by extending `kizunapi` in
future.

### `cppgc` and Node-API

If you have read the [design doc](https://github.com/compilets/compilets/blob/main/docs/design.md)
you might remember that the classes are managed with garbage collection using
`cppgc`, the Oilpan GC of V8. However unfortuantely the Node-API currently does
not work with `cppgc`, which means while the C++ classes are managed with
`cppgc`, we can not bind them to the JavaScript wrappers.

Currently it is work-arounded by wrapping the C++ classes in `cppgc::Persistent`
when passing to JavaScript. We will extend the Node-API in Node.js to solve
this.

## Building

After generating the C++ project, running `compilets build` would actually start
building the project, which runs `ninja -C cpp-project/out/Release` under the
hood using [ninja](https://ninja-build.org).

The native module is generated as the
`cpp-project/out/Release/${projectName}.node` file, which can be loaded in
Node.js like the normal [C++ addons](https://nodejs.org/api/addons.html).

## Compatibility with other JavaScript runtimes

There are many JavaScript runtimes supporting native modules built with
Node-API, however currently the native modules generated by Compilets can only
be loaded by the official Node.js due to relying on `cppgc` headers.

We can solve this by linking `cppgc` statically with the native module and then
setup `cppgc` to work with general Node-API, but Compilets is still under heavy
development and we want to keep this part of code as simple as possible to avoid
slowing down future works, so Compilets is going to stick with Node.js for a
while.
